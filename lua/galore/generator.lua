-- generates searches
-- searches generated by this module is order dependant
-- and unique.

local ordered = require('galore.lib.ordered')
local runtime = require('galore.runtime')
local nm = require('notmuch')

local Gen = {}

local Saved = {}

local runtime_dir = vim.fn.stdpath('data') .. '/galore'
local save_file = runtime_dir .. '/nm_saved.txt'

function Saved.add_saved(entry)
  local fp = assert(io.open(save_file, 'a'))
  local str = vim.json.encode(entry)
  fp:write(str .. '\n')
  fp:close()
end

--- this should be removed in favor of query.notmuch
function Saved.save_search(query)
  vim.ui.input({
    prompt="Name for saved search: "
  }, function(input)
    input = assert(input)
    Saved.add_saved({
      name = input,
      query = query,
    })
  end)
end

function Saved.edit_saved()
  if vim.fn.filereadable(save_file) ~= 0 then
    vim.cmd(':e ' .. save_file)
  end
end

function Saved.iterate_saved()
  return io.lines(save_file)
end

-- TODO: 
-- how to display saved queries from config

-- make_entry should take a table with the following values:
-- name: the name of the search (required)
-- query: the search (required)
-- count-query: (optional) query to use for the counting
-- count-special-query: (optional) special messages in a query, default is tag:unread
-- exclude: What tags to exclude (optional)
-- sort-order: how to sort the search (optional, if not specified, the default order is used)
-- browser: what browser should be use with this search, if not specified, the default one is used)


function Gen:new()
  local this = {
    ord = ordered.new()
  }
  self.__index = self
  setmetatable(this, self)
  return this
end

local function make_entry(db, entry)
  exclude = exclude or {}

  local q = nm.create_query(db, entry.query)
  for _, ex in ipairs(exclude) do
    -- we don't really care if the tags are removed or not, we want to do best effort
    pcall(function()
      nm.query_add_tag_exclude(q, ex)
    end)
  end
  local unread_q = nm.create_query(db, entry.query .. ' and tag:unread')
  local i = nm.query_count_messages(q)
  local unread_i = nm.query_count_messages(unread_q)
  -- table.insert(box, { i, unread_i, name, search })
end

local function prettyprint(tag)
  local num, unread, name, search = unpack(tag)
  local left = string.format('%d(%d) %s', num, unread, name)
  return string.format('%-35s (%s)', left, search)
end

function Gen:gen_tags(exclude)
  runtime.with_db(function(db)
    for tag in nm.db_get_all_tags(db) do
      local query = 'tag:' .. tag
      ordered.insert(self.ord, query, {
        name = tag,
        query = query,
        exclude =  exclude })
    end
  end)
end

function Gen:gen_internal()
  for line in Saved.iterate_saved() do
    local entry = assert(vim.json.decode(line))
    ordered.insert(self.ord, entry.name, entry)
  end
end

function Gen:custom(gen)
  for entry in gen() do
    ordered.insert(self.ord, entry.name, entry)
  end
end

function Gen:saved_queries(excluded)
  runtime.with_db(function (db)
    for k, v in nm.get_pairs(db, "query") do
      if k and v then
        local entry = {
          query = "query:" .. v,
          name = k,
        }
        ordered.insert(self.ord, entry.search, entry)
      end
    end
  end)
end

--- Only generate the excluded.
--- For istance, say you have Archive excluded from your
--- searches. Then you might use this one to list Archive.
function Gen:gen_excluded(excluded)
  for _, tag in ipairs(excluded) do
    local query = 'tag:' .. tag
    ordered.insert(self.ord, query, {
      name = tag,
      query = query })
  end
end

return Gen
